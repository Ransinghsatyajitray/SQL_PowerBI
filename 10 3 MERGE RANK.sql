CREATE TABLE tblOrders  ( 
ID INT NOT NULL PRIMARY KEY, TitleTag NVARCHAR(30) NOT NULL, Measure INT NOT NULL DEFAULT 0 )

CREATE TABLE tblInventory  ( 
ID INT NOT NULL PRIMARY KEY, TitleTag NVARCHAR(30) NOT NULL, Measure INT NOT NULL DEFAULT 0 )

INSERT tblOrders VALUES 	 (1, 'Comedy', 100),  (2, 'NEGOT', 100), (3, 'BUSINESS', 100)
INSERT tblInventory VALUES  	(3, 'BUSN PROFILES', 200),  (4, 'PB CHAPTER BKS', 200), 
				 (5, 'BEG READER HC', 200),  (6, 'Literature', 200)

SELECT * FROM tblOrders
SELECT * FROM tblInventory

-- MERGE	:	 A MECHANISM TO COMPARE TWO TABLES AND IDENTIFY MATCHING & MISSING DATA
-- WE CAN ALSO PERFORM DML OPERATIONS ON THE BASIS OF MATCHING & MISSING DATA.
/*
SYNTAX:
	MERGE <TARGET TABLE FOR DML OPERATIONS>
	USING SOURCETABLE
	ON
	<CONDITION TO COMPARE TWO TABLES>
	WHEN MATCHED		THEN	<DML OPERATION ON TARGET TABLE>
	WHEN NOT MATCHED	THEN	<DML OPERATION ON TARGET TABLE>
	;
*/


MERGE tblInventory
USING tblOrders
ON
tblInventory.ID = tblOrders.ID 
WHEN MATCHED THEN		UPDATE	SET tblInventory.MEASURE = tblInventory.MEASURE + tblOrders.MEASURE
WHEN NOT MATCHED THEN	INSERT  VALUES (tblOrders.ID, tblOrders.TITLETAG, tblOrders.MEASURE)
;

SELECT * FROM tblInventory

-- IIF : IF AND ONLY IF.  IIF(A>B, C, D) MEANS IF A > B THEN REPORT C  OR ELSE REPORT D

SELECT *, IIF(MEASURE = 100, 'ROW from Orders', 'ROW from Inventory') AS RSTATUS  FROM tblInventory


SELECT *,  CASE		WHEN MEASURE = 100	THEN 'ROW FROM ORDERS'
					WHEN MEASURE = 200	THEN 'ROW FROM INVENTORY'
					WHEN MEASURE = 300	THEN 'ROW FROM ORDERS & INVENTORY' 
					ELSE  'NO GRADE AVAILABLE'
			END  AS ROW_STATUS  FROM tblInventory


-- RANK FUNCTIONS:
-- TEMPORARY TABLE : SUCH TABLES CREATED AND STORED IN TEMPDB. FOR TEPORARY OPERATIONS
-- LOCAL TEMPORARY TABLE : AVAILABLE FOR USE WITHIN THE SESSION [QUERY WINDOW]	PREFIX : #
-- GLOBAL TEMPORARY TABLE : AVAILABLE FOR USE WITHIN THE ENTIRE CONNECTION.		PREFRIX: ##

CREATE TABLE #ServiceSales (ServiceType VARCHAR(80), SalesYear INT, NoOfLeads int);
 
INSERT #ServiceSales VALUES 	('SQL SEVER TRAINING', 2014, 1200),
	('SQL SEVER TRAINING', 2015, 1900),('SQL SEVER TRAINING', 2016, 2300);
INSERT #ServiceSales VALUES	('SQL DBA TRAINING', 2014, 4000),
	('SQL DBA TRAINING', 2015, 5500), ('SQL DBA TRAINING', 2016, 5900);
INSERT #ServiceSales VALUES	('MSBI TRAINING', 2014, 900),
	('MSBI TRAINING', 2015, 1800),   ('MSBI TRAINING', 2016, 2300)
INSERT #ServiceSales VALUES	('POWER BI TRAINING',2016,150),('POWER BI TRAINING',2017,100);
INSERT #ServiceSales VALUES	('CASE STUDIES n PROJECTS', 2015, 1000),
	('CASE STUDIES n PROJECTS', 2016, 2800),('CASE STUDIES n PROJECTS', 2017, 4000);

SELECT * FROM #ServiceSales

-- HOW TO GENERATE A UNIQUE SEQUENCE VALUES?
SELECT *, ROW_NUMBER() OVER (ORDER BY  ServiceType) AS ROW_NUMBER_SEQUENCE FROM #ServiceSales

SELECT *, RANK() OVER (ORDER BY  ServiceType) AS RANK_NUMBER_SEQUENCE FROM #ServiceSales

SELECT *, DENSE_RANK() OVER (ORDER BY  ServiceType) AS RANK_NUMBER_SEQUENCE FROM #ServiceSales

SELECT *, ROW_NUMBER() OVER (PARTITION BY ServiceType ORDER BY  ServiceType) AS RWNUMBER FROM #ServiceSales









SELECT *, ROW_NUMBER() OVER (ORDER BY ServiceType) FROM #ServiceSales
SELECT *, RANK() OVER (ORDER BY ServiceType) FROM #ServiceSales
SELECT *, DENSE_RANK() OVER (ORDER BY ServiceType) FROM #ServiceSales

SELECT *, ROW_NUMBER() OVER (PARTITION BY ServiceType ORDER BY ServiceType) FROM #ServiceSales

-- ROW_NUMBER	:	A UNIQUE NUMBER FOR EVERY ROW
-- RANK			:	SAME SEQUENCE FOR REPEATED VALUE. NEW SEQUENCE DEPENDS ON ROW NUMBER
-- DENSE_RANK	:	SAME SEQUENCE FOR REPEATED VALUE. NEW SEQUENCE DEPENDS ON PREVIOUS SEQUENCE
-- PARTITION BY	:	A UNIQUE SEQUENCE FOR REPEATED VALUES. SEQUENCE REPEATS FOR EVERY REPEATED VALUE